From ca5de379e95cdc13af0365408fa840ed7e5b7c53 Mon Sep 17 00:00:00 2001
From: t20kdc <asdd2808@gmail.com>
Date: Fri, 11 Oct 2024 17:33:15 +0100
Subject: [PATCH 1/2] NewKey, InfraStatusHost, 236.0.0, 13

---
 .../ServerStatus/StatusHost.Handlers.cs       |   1 +
 .../ServerStatus/StatusHost.NewKey.cs         | 104 ++++++++++++++++++
 Robust.Shared/CVars.cs                        |  10 ++
 Robust.Shared/Network/IServerNetManager.cs    |   8 ++
 Robust.Shared/Network/NetManager.NewKey.cs    |  49 +++++++++
 5 files changed, 172 insertions(+)
 create mode 100644 Robust.Server/ServerStatus/StatusHost.NewKey.cs
 create mode 100644 Robust.Shared/Network/NetManager.NewKey.cs

diff --git a/Robust.Server/ServerStatus/StatusHost.Handlers.cs b/Robust.Server/ServerStatus/StatusHost.Handlers.cs
index 5ab298643..4d8a4dacd 100644
--- a/Robust.Server/ServerStatus/StatusHost.Handlers.cs
+++ b/Robust.Server/ServerStatus/StatusHost.Handlers.cs
@@ -18,6 +18,7 @@ namespace Robust.Server.ServerStatus
             AddHandler(HandleTeapot);
             AddHandler(HandleStatus);
             AddHandler(HandleInfo);
+            AddHandler(HandleNewKey);
             AddAczHandlers();
         }
 
diff --git a/Robust.Server/ServerStatus/StatusHost.NewKey.cs b/Robust.Server/ServerStatus/StatusHost.NewKey.cs
new file mode 100644
index 000000000..84003289b
--- /dev/null
+++ b/Robust.Server/ServerStatus/StatusHost.NewKey.cs
@@ -0,0 +1,104 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading;
+using System.Threading.Tasks;
+using System.Net;
+using System.Net.Http.Headers;
+using System.Security.Cryptography;
+using System.Text;
+using System.Text.Json;
+using System.Text.Json.Nodes;
+using System.Text.Json.Serialization;
+using System.Text.Json.Nodes;
+using System.Web;
+using JWT;
+using JWT.Algorithms;
+using JWT.Builder;
+using JWT.Exceptions;
+using JWT.Serializers;
+using Robust.Shared;
+using Robust.Shared.Utility;
+using Robust.Shared.IoC;
+
+namespace Robust.Server.ServerStatus;
+
+internal sealed partial class StatusHost
+{
+    private async Task<bool> HandleNewKey(IStatusHandlerContext context)
+    {
+        var url = context.Url;
+        if (url.AbsolutePath != "/newkeyauth")
+        {
+            return false;
+        }
+
+        if (!context.RequestHeaders.TryGetValue("X-NewKey-JWT", out var jwt))
+        {
+            await context.RespondErrorAsync(HttpStatusCode.Unauthorized);
+            return true;
+        }
+
+        if (!context.RequestHeaders.TryGetValue("X-NewKey-Pubkey", out var userPublicKeyStr))
+        {
+            await context.RespondErrorAsync(HttpStatusCode.Unauthorized);
+            return true;
+        }
+
+        // Alright, now we get to the fun part: figuring out who this is.
+        JwtParsedFields json;
+        ECDsa userPublicKey;
+        try
+        {
+            var serializer = new JsonNetSerializer();
+            var provider = new UtcDateTimeProvider();
+            var validator = new JwtValidator(serializer, provider);
+            var urlEncoder = new JwtBase64UrlEncoder();
+
+            userPublicKey = ECDsa.Create();
+            userPublicKey.ImportFromPem(Encoding.UTF8.GetString(Convert.FromBase64String(userPublicKeyStr!)));
+
+            var algorithm = new ES256Algorithm(userPublicKey);
+            var decoder = new JwtDecoder(serializer, validator, urlEncoder, algorithm);
+
+            json = decoder.DecodeToObject<JwtParsedFields>(jwt);
+            // _httpSawmill.Debug("NewKey: Decoded JWT: " + decoder.Decode(jwt));
+        }
+        catch (Exception e)
+        {
+            await context.RespondAsync(e.ToString(), HttpStatusCode.Unauthorized);
+            return true;
+        }
+
+        var myAudience = _netManager.CryptoPublicKey != null
+                    ? Convert.ToBase64String(_netManager.CryptoPublicKey)
+                    : null;
+
+        if (json.Aud != myAudience)
+        {
+            await context.RespondAsync("Server public key mismatch", HttpStatusCode.Unauthorized);
+            return true;
+        }
+
+        var userPublicKeyX509Der = userPublicKey.ExportSubjectPublicKeyInfo();
+
+        var incHash = IncrementalHash.CreateHash(HashAlgorithmName.SHA256);
+        incHash.AppendData(userPublicKeyX509Der);
+        incHash.AppendData(Encoding.UTF8.GetBytes(_cfg.GetCVar(CVars.AuthNewKeySalt)));
+        var hash = incHash.GetHashAndReset();
+
+        // Alright, now we convert this hash to a GUID.
+        // This is the opposing statement to the & 0x7F in NetManager.ServerAuth.cs
+        // That kicks server GUIDs into one namespace, this kicks decentralized GUIDs into another.
+        hash[7] |= 0x80;
+        var guid = new Guid(new ReadOnlySpan<byte>(hash).Slice(0, 16));
+        var authHash = json.AuthHash;
+
+        _netManager.NewKeyPutHash(authHash, guid);
+
+        await context.RespondAsync($"Received and understood, {guid} {authHash}", (HttpStatusCode) 200);
+        return true;
+    }
+
+    private sealed record JwtParsedFields(string? Aud, string AuthHash);
+}
diff --git a/Robust.Shared/CVars.cs b/Robust.Shared/CVars.cs
index ebd4e29b2..58074fdb1 100644
--- a/Robust.Shared/CVars.cs
+++ b/Robust.Shared/CVars.cs
@@ -893,6 +893,16 @@ namespace Robust.Shared
         public static readonly CVarDef<string> AuthServer =
             CVarDef.Create("auth.server", AuthManager.DefaultAuthServer, CVar.SERVERONLY);
 
+        /// <summary>
+        /// NewKey salt.
+        /// This randomizes the mapping from user public keys to GUIDs.
+        /// This is kept hidden from clients.
+        /// Using this cvar adds extra security, but is not strictly required.
+        /// 'Mining' a GUID would take roughly the hashpower of the Bitcoin network going for at least a thousand years.
+        /// </summary>
+        public static readonly CVarDef<string> AuthNewKeySalt =
+            CVarDef.Create("auth.newkey_salt", "", CVar.SERVERONLY | CVar.CONFIDENTIAL);
+
         /*
          * RENDERING
          */
diff --git a/Robust.Shared/Network/IServerNetManager.cs b/Robust.Shared/Network/IServerNetManager.cs
index 6da688fe6..a8ecfc104 100644
--- a/Robust.Shared/Network/IServerNetManager.cs
+++ b/Robust.Shared/Network/IServerNetManager.cs
@@ -21,5 +21,13 @@ namespace Robust.Shared.Network
         /// <param name="channel">NetChannel to disconnect.</param>
         /// <param name="reason">Reason why it was disconnected.</param>
         void DisconnectChannel(INetChannel channel, string reason);
+
+        /// <summary>
+        /// NewKey: Put authhash into authentication cache.
+        /// </summary>
+        void NewKeyPutHash(string authHash, Guid guid)
+        {
+            // Default must be here to reduce conflicts with integration testing
+        }
     }
 }
diff --git a/Robust.Shared/Network/NetManager.NewKey.cs b/Robust.Shared/Network/NetManager.NewKey.cs
new file mode 100644
index 000000000..9c6268cba
--- /dev/null
+++ b/Robust.Shared/Network/NetManager.NewKey.cs
@@ -0,0 +1,49 @@
+using System;
+using System.Collections.Generic;
+using System.Threading;
+using System.Threading.Tasks;
+using Robust.Shared.IoC;
+using Robust.Shared.Utility;
+
+namespace Robust.Shared.Network;
+
+public sealed partial class NetManager
+{
+    // Generated this way for compatibility with older versions.
+    private static readonly string DisconnectReasonNewKeyError = "{\n\"reason\":\"NewKey token not received or didn't match.\\nPlease reconnect to this server from the launcher.\",\n\"redial\":true\n}";
+
+    private readonly SemaphoreSlim _newkeyLock = new(1, 1);
+    private readonly Dictionary<string, Guid> _newkeyDict = new();
+
+    public Guid? NewKeyGetHash(string authHash)
+    {
+        _logger.Debug("NewKey: TryNewKeyServerAuthArrange(" + authHash + ")");
+        using (var _ = _newkeyLock.WaitGuard())
+        {
+            if (_newkeyDict.TryGetValue(authHash, out var guid))
+            {
+                return guid;
+            }
+        }
+        return null;
+    }
+
+    public void NewKeyPutHash(string authHash, Guid guid)
+    {
+        _logger.Debug("NewKey: Authorized AuthHash: " + authHash);
+
+        using (var _ = _newkeyLock.WaitGuard())
+        {
+            _newkeyDict[authHash] = guid;
+        }
+
+        Task.Run(async () =>
+        {
+            await Task.Delay(60000);
+            using (var _ = _newkeyLock.WaitGuard())
+            {
+                _newkeyDict.Remove(authHash);
+            }
+        });
+    }
+}
-- 
2.43.0

