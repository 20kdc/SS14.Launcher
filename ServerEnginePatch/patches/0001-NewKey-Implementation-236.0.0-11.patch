From 9b4732723d432bd0b35955b2e0602749d9716e37 Mon Sep 17 00:00:00 2001
From: t20kdc <asdd2808@gmail.com>
Date: Fri, 11 Oct 2024 17:33:15 +0100
Subject: [PATCH] NewKey, Implementation, 236.0.0, 11

---
 .../ServerStatus/StatusHost.Handlers.cs       |   1 +
 .../ServerStatus/StatusHost.NewKey.cs         | 104 ++++++++++++++++++
 Robust.Shared/CVars.cs                        |  10 ++
 Robust.Shared/Network/IServerNetManager.cs    |   5 +
 Robust.Shared/Network/NetManager.NewKey.cs    |  49 +++++++++
 .../Network/NetManager.ServerAuth.cs          |  35 +++++-
 .../RobustIntegrationTest.NetManager.cs       |   5 +
 7 files changed, 208 insertions(+), 1 deletion(-)
 create mode 100644 Robust.Server/ServerStatus/StatusHost.NewKey.cs
 create mode 100644 Robust.Shared/Network/NetManager.NewKey.cs

diff --git a/Robust.Server/ServerStatus/StatusHost.Handlers.cs b/Robust.Server/ServerStatus/StatusHost.Handlers.cs
index 5ab298643..4d8a4dacd 100644
--- a/Robust.Server/ServerStatus/StatusHost.Handlers.cs
+++ b/Robust.Server/ServerStatus/StatusHost.Handlers.cs
@@ -18,6 +18,7 @@ namespace Robust.Server.ServerStatus
             AddHandler(HandleTeapot);
             AddHandler(HandleStatus);
             AddHandler(HandleInfo);
+            AddHandler(HandleNewKey);
             AddAczHandlers();
         }
 
diff --git a/Robust.Server/ServerStatus/StatusHost.NewKey.cs b/Robust.Server/ServerStatus/StatusHost.NewKey.cs
new file mode 100644
index 000000000..84003289b
--- /dev/null
+++ b/Robust.Server/ServerStatus/StatusHost.NewKey.cs
@@ -0,0 +1,104 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading;
+using System.Threading.Tasks;
+using System.Net;
+using System.Net.Http.Headers;
+using System.Security.Cryptography;
+using System.Text;
+using System.Text.Json;
+using System.Text.Json.Nodes;
+using System.Text.Json.Serialization;
+using System.Text.Json.Nodes;
+using System.Web;
+using JWT;
+using JWT.Algorithms;
+using JWT.Builder;
+using JWT.Exceptions;
+using JWT.Serializers;
+using Robust.Shared;
+using Robust.Shared.Utility;
+using Robust.Shared.IoC;
+
+namespace Robust.Server.ServerStatus;
+
+internal sealed partial class StatusHost
+{
+    private async Task<bool> HandleNewKey(IStatusHandlerContext context)
+    {
+        var url = context.Url;
+        if (url.AbsolutePath != "/newkeyauth")
+        {
+            return false;
+        }
+
+        if (!context.RequestHeaders.TryGetValue("X-NewKey-JWT", out var jwt))
+        {
+            await context.RespondErrorAsync(HttpStatusCode.Unauthorized);
+            return true;
+        }
+
+        if (!context.RequestHeaders.TryGetValue("X-NewKey-Pubkey", out var userPublicKeyStr))
+        {
+            await context.RespondErrorAsync(HttpStatusCode.Unauthorized);
+            return true;
+        }
+
+        // Alright, now we get to the fun part: figuring out who this is.
+        JwtParsedFields json;
+        ECDsa userPublicKey;
+        try
+        {
+            var serializer = new JsonNetSerializer();
+            var provider = new UtcDateTimeProvider();
+            var validator = new JwtValidator(serializer, provider);
+            var urlEncoder = new JwtBase64UrlEncoder();
+
+            userPublicKey = ECDsa.Create();
+            userPublicKey.ImportFromPem(Encoding.UTF8.GetString(Convert.FromBase64String(userPublicKeyStr!)));
+
+            var algorithm = new ES256Algorithm(userPublicKey);
+            var decoder = new JwtDecoder(serializer, validator, urlEncoder, algorithm);
+
+            json = decoder.DecodeToObject<JwtParsedFields>(jwt);
+            // _httpSawmill.Debug("NewKey: Decoded JWT: " + decoder.Decode(jwt));
+        }
+        catch (Exception e)
+        {
+            await context.RespondAsync(e.ToString(), HttpStatusCode.Unauthorized);
+            return true;
+        }
+
+        var myAudience = _netManager.CryptoPublicKey != null
+                    ? Convert.ToBase64String(_netManager.CryptoPublicKey)
+                    : null;
+
+        if (json.Aud != myAudience)
+        {
+            await context.RespondAsync("Server public key mismatch", HttpStatusCode.Unauthorized);
+            return true;
+        }
+
+        var userPublicKeyX509Der = userPublicKey.ExportSubjectPublicKeyInfo();
+
+        var incHash = IncrementalHash.CreateHash(HashAlgorithmName.SHA256);
+        incHash.AppendData(userPublicKeyX509Der);
+        incHash.AppendData(Encoding.UTF8.GetBytes(_cfg.GetCVar(CVars.AuthNewKeySalt)));
+        var hash = incHash.GetHashAndReset();
+
+        // Alright, now we convert this hash to a GUID.
+        // This is the opposing statement to the & 0x7F in NetManager.ServerAuth.cs
+        // That kicks server GUIDs into one namespace, this kicks decentralized GUIDs into another.
+        hash[7] |= 0x80;
+        var guid = new Guid(new ReadOnlySpan<byte>(hash).Slice(0, 16));
+        var authHash = json.AuthHash;
+
+        _netManager.NewKeyPutHash(authHash, guid);
+
+        await context.RespondAsync($"Received and understood, {guid} {authHash}", (HttpStatusCode) 200);
+        return true;
+    }
+
+    private sealed record JwtParsedFields(string? Aud, string AuthHash);
+}
diff --git a/Robust.Shared/CVars.cs b/Robust.Shared/CVars.cs
index ebd4e29b2..58074fdb1 100644
--- a/Robust.Shared/CVars.cs
+++ b/Robust.Shared/CVars.cs
@@ -893,6 +893,16 @@ namespace Robust.Shared
         public static readonly CVarDef<string> AuthServer =
             CVarDef.Create("auth.server", AuthManager.DefaultAuthServer, CVar.SERVERONLY);
 
+        /// <summary>
+        /// NewKey salt.
+        /// This randomizes the mapping from user public keys to GUIDs.
+        /// This is kept hidden from clients.
+        /// Using this cvar adds extra security, but is not strictly required.
+        /// 'Mining' a GUID would take roughly the hashpower of the Bitcoin network going for at least a thousand years.
+        /// </summary>
+        public static readonly CVarDef<string> AuthNewKeySalt =
+            CVarDef.Create("auth.newkey_salt", "", CVar.SERVERONLY | CVar.CONFIDENTIAL);
+
         /*
          * RENDERING
          */
diff --git a/Robust.Shared/Network/IServerNetManager.cs b/Robust.Shared/Network/IServerNetManager.cs
index 6da688fe6..9edeb5895 100644
--- a/Robust.Shared/Network/IServerNetManager.cs
+++ b/Robust.Shared/Network/IServerNetManager.cs
@@ -21,5 +21,10 @@ namespace Robust.Shared.Network
         /// <param name="channel">NetChannel to disconnect.</param>
         /// <param name="reason">Reason why it was disconnected.</param>
         void DisconnectChannel(INetChannel channel, string reason);
+
+        /// <summary>
+        /// NewKey: Put authhash into authentication cache.
+        /// </summary>
+        void NewKeyPutHash(string authHash, Guid guid);
     }
 }
diff --git a/Robust.Shared/Network/NetManager.NewKey.cs b/Robust.Shared/Network/NetManager.NewKey.cs
new file mode 100644
index 000000000..9c6268cba
--- /dev/null
+++ b/Robust.Shared/Network/NetManager.NewKey.cs
@@ -0,0 +1,49 @@
+using System;
+using System.Collections.Generic;
+using System.Threading;
+using System.Threading.Tasks;
+using Robust.Shared.IoC;
+using Robust.Shared.Utility;
+
+namespace Robust.Shared.Network;
+
+public sealed partial class NetManager
+{
+    // Generated this way for compatibility with older versions.
+    private static readonly string DisconnectReasonNewKeyError = "{\n\"reason\":\"NewKey token not received or didn't match.\\nPlease reconnect to this server from the launcher.\",\n\"redial\":true\n}";
+
+    private readonly SemaphoreSlim _newkeyLock = new(1, 1);
+    private readonly Dictionary<string, Guid> _newkeyDict = new();
+
+    public Guid? NewKeyGetHash(string authHash)
+    {
+        _logger.Debug("NewKey: TryNewKeyServerAuthArrange(" + authHash + ")");
+        using (var _ = _newkeyLock.WaitGuard())
+        {
+            if (_newkeyDict.TryGetValue(authHash, out var guid))
+            {
+                return guid;
+            }
+        }
+        return null;
+    }
+
+    public void NewKeyPutHash(string authHash, Guid guid)
+    {
+        _logger.Debug("NewKey: Authorized AuthHash: " + authHash);
+
+        using (var _ = _newkeyLock.WaitGuard())
+        {
+            _newkeyDict[authHash] = guid;
+        }
+
+        Task.Run(async () =>
+        {
+            await Task.Delay(60000);
+            using (var _ = _newkeyLock.WaitGuard())
+            {
+                _newkeyDict.Remove(authHash);
+            }
+        });
+    }
+}
diff --git a/Robust.Shared/Network/NetManager.ServerAuth.cs b/Robust.Shared/Network/NetManager.ServerAuth.cs
index 8296c446d..4af9df0b1 100644
--- a/Robust.Shared/Network/NetManager.ServerAuth.cs
+++ b/Robust.Shared/Network/NetManager.ServerAuth.cs
@@ -138,7 +138,31 @@ namespace Robust.Shared.Network
                     var authHash = Base64Helpers.ConvertToBase64Url(authHashBytes);
 
                     var url = $"{authServer}api/session/hasJoined?hash={authHash}&userId={msgEncResponse.UserId}";
-                    var joinedRespJson = await _http.Client.GetFromJsonAsync<HasJoinedResponse>(url);
+                    // NewKey: Launcher embeds signalling into the username which client passes.
+                    // This signal tells us to ask Status for help.
+                    HasJoinedResponse? joinedRespJson;
+                    bool newkey = msgLogin.UserName.StartsWith("NK!", false, System.Globalization.CultureInfo.InvariantCulture);
+                    if (newkey)
+                    {
+                        var reqUserName = msgLogin.UserName.Substring(3);
+                        if (!UsernameHelpers.IsNameValid(reqUserName, out var reason))
+                        {
+                            connection.Disconnect($"Username is invalid ({reason.ToText()}).");
+                            return;
+                        }
+                        // Notably, ConvertToBase64Url is not the same thing.
+                        var res = NewKeyGetHash(Convert.ToBase64String(authHashBytes));
+                        if (res == null)
+                        {
+                            connection.Disconnect(DisconnectReasonNewKeyError);
+                            return;
+                        }
+                        joinedRespJson = NewKeyCreateHasJoinedResponse(reqUserName + "-" + res!, res!.Value);
+                    }
+                    else
+                    {
+                        joinedRespJson = await _http.Client.GetFromJsonAsync<HasJoinedResponse>(url);
+                    }
 
                     if (joinedRespJson is not {IsValid: true})
                     {
@@ -146,6 +170,15 @@ namespace Robust.Shared.Network
                         return;
                     }
 
+                    if (!newkey)
+                    {
+                        // NewKey: Defend against an auth server trying to claim keybound GUIDs
+                        var userGuid = joinedRespJson.UserData!.UserId;
+                        var bytes = joinedRespJson.UserData!.UserId.ToByteArray();
+                        bytes[7] &= 0x7F;
+                        joinedRespJson = joinedRespJson with { UserData = joinedRespJson.UserData! with { UserId = new Guid(bytes) }};
+                    }
+
                     _logger.Verbose(
                         $"{connection.RemoteEndPoint}: Auth hash passed. " +
                         $"User ID: {joinedRespJson.UserData!.UserId}, " +
diff --git a/Robust.UnitTesting/RobustIntegrationTest.NetManager.cs b/Robust.UnitTesting/RobustIntegrationTest.NetManager.cs
index 7553aa27a..b9e279a15 100644
--- a/Robust.UnitTesting/RobustIntegrationTest.NetManager.cs
+++ b/Robust.UnitTesting/RobustIntegrationTest.NetManager.cs
@@ -329,6 +329,11 @@ namespace Robust.UnitTesting
                 channel.Disconnect(reason);
             }
 
+            public Guid? NewKeyGetHash(string authHash) => null;
+            public void NewKeyPutHash(string authHash, Guid guid)
+            {
+            }
+
             INetChannel? IClientNetManager.ServerChannel => ServerChannel;
             public ClientConnectionState ClientConnectState => ClientConnectionState.NotConnecting;
 
-- 
2.43.0

